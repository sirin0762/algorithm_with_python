# 최단 경로
## 가장 빠른 길 찾기

최단 경로 알고리즘 유형에는 다양한 종류가 있는데, 상황에 맞는 효율적인 알고리즘이 이미 정립되어있다.    
최단 경로 알고리즘은 보통 그래프로 표현하는데 각 지점은 그래프에서 '노드'로 표현되고, 지점 간 연결된 도로는 그래프에서 '간선'으로 표현된다.   
컴공 학부 수준에서는 다익스트라, 플로이드 워셜, 벨만 포드 알고리즘, 이렇게 3가지에 대해서 정도 알고있으면 된다.   

앞서 공부한 그리드 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 그대로 적용 된다는 특징이 있다.

### 다익스트라 최단 경로 알고리즘
---
다익스트라 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다. 다익스트라 최단 경로 알고리즘은 '음의 간선' 이 없을 때 정상적으로 동작한다. '음의 간선' 이란 0보다 작은 값을 가지는 간선을 의미하는데, 현실 세계의 길은 음의 간선으로 표현되지 않으므로 다익스트라 알고리즘은 실제로 GPS 소프트웨어의 기본 알고리즘으로 채택되곤 한다.   

다익스트라 최단경로 알고리즘은 기본적으로 그리디 알고리즘으로 분듀된다. 매번 '가장 비용이 적은 노드'를  선택해서 임의의 과정을 반복하기 때문이다. 다음은 알고리즘의 간략한 원리이다.   
1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화한다.
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
5. 위 과정에서 3, 4를 반복한다.   

다익스트라 알고리즘은 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리' 정보를 항상 1차언 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.   

그림을 통한 동작원리는 책 232p ~ 236p 를 참고하면 된다.   

다익스트라 최단 경로 알고리즘에서는 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복하는데, 이렇게 선택된 노드는 '최단 거리'가 완전히 선택된 노드이므로, 더 이상의 알고리즘을 반복해도 최단 거리가 감소 되지 않는다.  
즉 각 루프마다 확실하게 1개의 노드에대한 최단 거리가 나오는 셈이다.   

다음은 다익스트라를 구현하는 2가지 방법에 대해 소개한다.

### 방법 1. 간단한 다익스트라 알고리즘
---
위의 방법을 토대로 알고리즘을 구현해보자. 간단한 다익스트라 알고리즘은 O(V<sup>2</sup>)을 가지며 V는 노드의 갯수이다. 처음에 각 노드에 대한 최단 거리를 담는 1차원 리스트를 선언한다. 이후에 단계마다 '방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택 하기 위해  매 단계마다 1차원 리스트의 모든 원소를 순차 탐색한다.   
사실 완벽한 '최단 경로' 를 구하기 위해서는 코드를 조금 수정해야한다. 우리가 구하는 것은 '최단 거리' 이다(사실 다익스트라 알고리즘은 최단 경로를 구하기 위한 알고리즘이다.).  

파일 9-1.py 를 참고하자.

### 방법 2. 개선된 다익스트라 알고리즘
---
이제 개선된 알고리즘을 알아보자. 방법 1에서 최소 거리를 가진 노드를 찾기위해 순차 탐색을 하였다.   
순차탐색의 복잡도는 O(N) 이기에 전체 복잡도는 O(N)<sup>2</sup>이 된다.   
하지만 순차 탐색 대신 자료구조로 heap을 사용하면 heap의 팝 기능을 이용하여 최소 노드를 찾으면 복잡도는 (ElogV) 가 되어 O(NlogN)이 된다.   
우리가 heap을 쓰는 이유는 heap으로 우선순위 큐를 만들 수 있기 때문이다. 우선 순위 큐는 우선 순위가 가장 높은 데이터를 가장 먼저 삭제 한다는 점이 특징이다.    
파이썬에서는 PriortyQueue 혹은 heapq 를 사용할 수 있는데, 일반적으로 heapq 라이브러리가 더 빠르게 동작하기 때문에 수행 시간이 제한된 상황에서는 heapq를 사용하는 것을 권장한다.
힙 큐에 튜플을 넣을 경우, 튜플의 index가 0인 데이터를 기준으로 큐가 정렬된다는 사실을 기억해야한다.   
정리하면, 현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이용한다고 보면 된다.   
자 이제 9-2.py 를 보자
 
### 플로이드 워셜 알고리즘
---
다익스트라 알고리즘은 '한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우에 사용 할 수 있는 최단 경로 알고리즘이다. 이번에 설명하는 플로이드 워셜 알고리즘은 '모든 지점에서 다른 모든 지점 까지의 최단 경로를 모두 구해야 하는 경우' 에 사용 할 수 있는 알고리즘이다.   
코딩 난이도는 굉장히 낮으나, 컨셉이해를 잘해야 한다.   
다익 스트라 알고리즘은 단계마다 최단 거리를 가지는 노드를 반복적으로 선택한다. 그리고 해당 노드를 거쳐 가는 경로를 확인하며, 최단 거리 테이블을 갱신하는 방식으로 동작한다. 플로이드 워셜 알고리즘 또한 단계마다 '거쳐 가는 노드' 를 기준으로 알고리즘을 수행한다. 하지만 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다.   
노드의 개수가 N개일 때 알고리즘상으로 N번의 단계를 수행하며, 단계 마다 O(N<sup>2</sup>)의 연산을 통해 '현재 노드를 거쳐 가는' 모든 경로를 고려한다. 따라서 플로이드 워셜 아고리즘의 총 시간 복잡도는 O(N<sup>3</sup>) 이다.   

다익스트라 알고리즘에서는 최단 거리를 저장하기 위해 1차원 리스트를 사용했지만, 플로이드 워셜 알고리즘은 모든 노드의 최단 경로를 저장해야하기 때문에 2차원 리스트를 사용한다.   

플로이드 워셜 알고리즘은 베이스로 다이나믹 프로그래밍을 가지고 있다. 노드의 개수가 N개 일 때, N번 만큼이 단계를 반복하며 '점화식에 맞게' 2차원 리스트를 갱신하기 때문에 다이나믹 프로그래밍으로 볼 수 있다.   

자 이제 알고리즘을 알아보자.

각 단계에서는 해당 노드를 거쳐 가는 경우를 고려한다. 예를 들어 1번 노드에 대해서 확인 할 때는 1번 노드를 중간에 거쳐지나가는 모든 경우를 고려하면 된다. 정확히는 A-> 1 -> B 로가는 비용을 확인 한 후에 최단 거리를 갱신한다. 
즉 D<sub>ab</sub> 는 min(D<sub>ak</sub> + D<sub>bk</sub>, D<sub>ab</sub>) 를 고려하면 끝이다.

예제 9-3.py 를 참고하자.
