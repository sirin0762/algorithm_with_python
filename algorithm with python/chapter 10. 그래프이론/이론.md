### 다양한 그래프 알고리즘
---
__이미 배운 내용을 훑어 보자__   

이번 장에서는 지금까지 다루지 않았던 그래프 알고리즘을 추가로 다룰 것이다.
10장에서 다룰 알고리즘은 앞서 배운 내용에 기반하는데, 예를 들어 크루스칼 알고리즘은 그리드 알고리즘으로 분류되며, 위상 정렬 알고리즘은 앞서 배운 큐 자료구조 혹은 스택 자료구조를 활용해야 구현할 수 있다.   

내용을 다루기 전에, 앞서 공부했던 그래프에 대해서 복습해보자. 먼저 그래프란 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조를 의미한다. 알고리즘 문제를 접했을 때 '서로 다른 개체 or 객체' 가 연결되어 있다 라는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야한다. 예를 들어 '여러 개의 도시가 연결되어 있다' 와 같은 내용이 등장하면 그래프 알고리즘을 의심해보자.   

더불어 그래프 자료구조 중에서 트리 자료구조는 다양한 알고리즘에서 사용되므로 꼭 기억하자.    
9장의 다익스트라 알고리즘에서는 우선순위 큐가 사용되었는데, 우선순위 큐를 구현하기 위해 최소 힙이나 최대 힙을 이용할 수 있다고 했다. 최소힙은 항상 부모노드가 더 작은 자료구조로서 트리 구조에 속한다. 트리 자료구조는 부모에서 자식으로 내려오는 계층적인 모델에 속한다. 그래프와 트리 자료구조를 비교하면 다음 표의 내용과 같다.   
참고로 트리는 전통적인 수학에서는 무방향 그래프로 간주되지만, 컴퓨터 공학에서는 보통 방향 그래프로 간주된다.   

또한 그래프의 구현 방법은 2가지 방식이 존재한다. 이를 다시 한번 간단히 요약하면 다음과 같다.  
<ul>
<li> 인접 행렬 : 2차원 배열을 사용하는 방식</li>
<li> 인접 리스트 : 리스트를 사용하는 방식</li>
</ul>   

2가지 모두 그래프 알고리즘에서 매우 많이 사용된다. 두 방식은 메모리와 속도 측면에서 구별되는 특징을 가진다는 점을 기억하자.      

9장에서 우선순위 큐를 이용하는 다익스트라 알고리즘은 인접 리스트를 이용하는 방식(boj 문제에서는 인접 행렬도 사용됨) 이다. 노드의 개수가 V개일 때는 V개의 리스트를 만들어서 각 노드와 연결된 모든 간선에 대한 정보를 리스트에 저장했다.   
플로이드 워셜 알고리즘은 인접 행렬을 이용하는 방식이다. 모든 노드에 대하여 다른 노드로 가는 최소 비용을 V<sup>2</sup>크기의 2차원 리스트에 저장한 뒤 해당 비용을 갱신해서 최단 거리를 개산했다.   
알아두어야 할 점은 어떤 문제를 만나든 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현해야한다는 것이다. 예를 들어 최단 경로를 찾아야 하는 문제가 출제 되었을 떄, 노드의 개수가 적은 경우에는 플로이드 워셜 알고리즘을 이용할 수 있다. 반면에 노드와 간선의 개수가 모두 많으면 우선 순위 큐를 이용하는 다익스트라 알고리즘을 이용하면 유리하다(boj 문제중에 이 부분을 다루는 문제가 있다).  지금 부터 기타 그래프 알고리즘을 익혀보자. 

___

__서로소 집합__  
수학에서 서로소 집합이란 공통 원소가 없는 두 집합을 의미한다. 에를 들어 집합 {1, 2}와 집합 {3, 4} 는 서로소 관계이다.   
서로소 집합 자료구조를 설명하려면 서로소 집합 개념이 필요하다. 서로소 집합 자료구조는 몇몇 그래프 알고리즘에서 매우 중요하게 사용되므로 그래프 알고리즘 이론 전에 설명하고자 한다.   
서로소 자료구조란 <b>서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조라고 할 수 있다.</b> 서로소 집합 자료구조는 union과 find 이 2개의 연산으로 조작할 수 있다. union<sup>합집합</sup> 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산이다. find 연산은 특정 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다. 스택과 큐는 각각 push와 pop 연산으로 이루어진 것 처럼 서로소 집합 자료구조는 합집합과 찾기 연산으로 구성된다.   
서로소 집합 자료구조는 union-find 자료구조라고 불리기도 한다. 연산의 이름 자체가 합치기와 찾기 이기도 하고, 두 집합이 서로소 관계인지를 확인할 수 있다는 말은 각 집합이 어떤 원소를 공통으로 가지고 있는지를 확인할 수 있다는 말과 같기 떄문이다.   
___

__서로소 집합 자료구조__  
서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현하는데, 서로소 집합 정보(합집합 연산)가 주어졌을 떄 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.   
1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.    
 1-1. A와 B의 루트 노드 A', B'을 각각 찾는다.     
 1-2. A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다).
2. 모든 union(합집합) 연산을 처리할 때 까지 1번 과정을 반복한다.   
이것이 트리를 이용해 서로소 집합을 계산하는 알고리즘이다. 또한 실제로 구현 할 때는 A'와 B'중에서 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많으므로. 이 책에서도 그러한 구현 방식을 따르도록 하겠다. A'가 1이고, B' 가 3이라면. B'가 A'를 가리키도록 설정한다. 여기서 '가리킨다'라는 표현은 부모로 삼겠다는 의미이다. 예를 들어 B'가 A'를 부모 노드로 설정하는 것을 그래프로 시각화 할 떄, B'와 A'를 간선으로 연결하는 형태로 그래프를 그릴 수 있다. 이어지는 step에 있는 그림을 보면 이해가 쉬울 것이다.   

예시를 통해서 서로소 집합 계산 알고리즘의 동작 방식을 이해해보도록 하자. 이번에는 전체 집합 {1, 2, 3, 4, 5, 6}이 6개의 원소로 구성되어 있는 상황을 생각해보자. 이때 다음과 같은 4개의 union 연산이 주어져있다.   
union 1, 4 / union 2, 3 / union 2, 4 / union 5, 6   
이러한 union연산들은 그래프 형태로 표현 될 수 있다. 각 원소는 그래프에서의 노드로 표현되고, '같은 집합에 속한다'는 정보를 담은 union 연산들은 간선으로 표현된다. 즉 예시에서는 6개의 노드와 4개의 간선이 있는 것이다.

10-1.py를 실행하면 우리가 앞서 그림으로 확인했던 것과 동일하다.   
다만 이렇게 구현하면 답을 구할 수는 있지만, find함수가 비효율적으로 동작한다.   
최악의 경우 find 함수가 모든 노드를 다 확인하는 터라 시간복잡도가 O(N) 라는 점이다.  
이 전 그림에서 노드 4를 보면 결국 루트 노드는 1이지만 3을 갔다가 2를 갔다가 1에 도착하는 것을 알수 있다.   
그러니 현재의 알고리즘을 그대로 이용하게 되면 노드의 개수가 V개이고 find 혹은 union 연산의 개수가 M개일 때, 전체 시간 복잡도는 O(VM)이 되어 비효율적이다.  

하지만 이러한 find 함수는 아주 간단한 과정으로 최적화가 가능하다. 바로 경로 압축 기법을 이용하면 시간복잡도를 개선할 수 있다.   
경로 압축은 find 함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법이다. 기존의 find 함수를 다음과 같이 변경하면 경로 압축 기법의 구현이 완료된다.
파일 10-2.py에 다음과 같은 기법을 설명했다.  
___

__서로소 집합 알고리즘의 시간 복잡도__   
서로소 집합 알고리즘을 구현할 때, 경로 압축 방법만을 이용할 경우의 시간 복잡도를 알아보자.   
노드의 개수가 V개 이고, 최대 V - 1개의 union 연산과 M개의 find 연산이 가능할 때 경로 압축 방법을 적용한 시간 복잡도는 O(V + M(1 + log<sub>2-M/V</sub>V))라는 것이 알려져있다.   
증명 과정은 이 책의 범위가 아니라서 생략한다. 예를 들어 노드의 개수가 1000개이고 union 및 find 연산이 100만 번 정도 수행되면, 약 1000만 번 가량의 연산이 필요하다고 이해하면 된다.
___   

__서로소 집합을 활용한 사이클 판별__   
서로소 집합은 다양한 알고리즘에 사용될 수 있다. 특히 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다는 특징이 있다. 참고로 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있으며, 해당 내용은 책에서 다루지는 않는다.   

앞서 union 연산은 그래프에서의 간선으로 표현될 수 있다고 했다. 따라서 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다.   
알고리즘은 다음과 같다.   
1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.   
1-1. 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.   
1-2. 루트 노드가 서로 같다면 사이클이 발생한 것이다.   
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.

다음 예시를 통해 확인해보자(1, 2, 3 번 노드가 모두 연결되어있음)

step 0. 초기단계에서는 모든 노드에 대하여 자기 자신을 부모로 설정하는 형태로 초기화 한다.   
| 인덱스 | 1 | 2 | 3 |
|-----|---|---|---|
| 루트 | 1 | 2 | 3 |
   
step 1. 가정 먼저 간선 (1, 2)를 확인한다. 노드 1과 노드 2의 루트 노드는 각각 1과 2이다.   
따라서 더 큰 번호를 갖는 노드 2의 부모 노드를 1로 변경한다.   
| 인덱스 | 1 | 2 | 3 |
|-----|---|---|---|
| 루트 | 1 | 1 | 3 |

step 2. 이어서 간선 (1, 3)을 확인한다. 노드 1과 노드 3의 루트 노드는 각각 1과 3이다.   
따라서 더 큰 번호를 갖는 노드 2의 부모 노드를 1로 변경한다.   
| 인덱스 | 1 | 2 | 3 |
|-----|---|---|---|
| 루트 | 1 | 1 | 1 |

step 3. 이후에 간선 (2, 3) 간선을 확인한다. 다만, 이때 노드 2와 노드 3이 이미 루트 노드로 ' 노드 1;을 가지고 있다. 다시 말해서 사이클이 발생한다는 것을 알 수 있다.   

이러한 사이클 판별 알고리즘은 모든 간선을 하나씩 확인하며, 매 간선에 대하여 union 및 find 함수를 호출하는 방식으로 동작한다. 이 알고리즘은 간선에 방향이 없는 무향 그래프에서만 적용 가능하다.   

10-4.py 예제를 참고하자.
___

### 신장 트리
신장 트리는 그래프 알고리즘 문제로 자주 출제되는 문제 유형이다. 기본적으로 신장 트리란 **하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프**를 의미한다.   
이때 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 부분 그래프를 의미한다.

___

__크루스칼 알고리즘__   

우리는 다양한 문제 상황에서 가능한 한 최소한의 비용으로 신장트리를 찾아야 할 대가 있다. 예를 들어 N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 전체 도시가 서로 연결될 수 있게 도로를 설치하는 경우를 생각해보자. 2개의 도서 A, B를 선택했을 때, 도시 A에서 도시 B로 이동하는 경로가 반드시 존재하도록 도로를 설치하고자 한다. 모든 도시를 '연결'할 때, 최소한의 비용으로 연결 하려면 어떤 알고리즘을 이용해야 할까?   

신장 트리 중에서 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘을 '최소 신장  트리 알고리즘' 이라고 한다. 대표적인 최소 신장 트리 알고리즘은 **크루스칼 알고리즘** 이다.   
크루스칼 알고리즘은 그리디 알고리즘으로 분류된다. 먼저 모든 간선에 대하여 정렬을 수행한 다음에, 가장 거리가 짧은 간선부터 집합에 포함 시키면 된다. 이 때 사이클을 발생시킬 수 있는 간선의 경우, 집합에 포함시키지 않는다.   
구체적인 알고리즘은 다음과 같다.
1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.   
2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.   
2-1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.   
2-2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
3. 모든 간선에 대하여 2의 과정을 반복한다.   

최소 신장 트리는 일종의 트리 자료구조이므로, 최종적으로 신장 트리에 포함되는 간선의 개수가 '노드의 개수 - 1' 과 같다는 특징이 있다.

자세한 과정은 예제 10-5.py 를 참고하자.   
___
### 위상 정렬

위상 정렬<sup>Topology sort</sup>은 정렬 알고리즘의 일종이다. 위상 정렬은 순서가 정해져있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘이다.   
위상 정렬이란 **방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'이다.   
현실 세계에서 위상 정렬을 수행하게 되는 전형적인 예시로는 '선수과목을 고려한 학습 순서 설정'을 들 수 있다.   
예를 들어 컴퓨터 공학과 커리큘럼에는 '자료구조' 과목을 수강한 뒤에 '알고리즘' 강의를 수강하는 것을 권장한다. 이때 자료구조 및 알고리즘을 각각의 노드로 표현하고, 자료구조에서 알고리즘으로 이어질 수 있도록 방향성을 갖는 간선을 그릴 수 있다. 다시 말해 그래프상에서 선후 관계가 있다면, 위상 정렬을 수행하여 모든 선후 관계를 지키는 전체 순서를 계산할 수 있다.   
다시 예를 들면 컴공의 커리큘럼이 다음 그림과 같이 총 3개의 과목만으로 구성되고 '알고리즘'의 선수 과목으로 자료구조가 있다고 하자. 또한 고급 알고리즘의 선수과목으로 자료구조와 알고리즘이 있다고 가정하자. 이 경우 모든 과목을 수강하기 위해서는 자료구조 -> 알고리즘 -> 고급 알고리즘 순서로 강의를 수강해야 한다.   
위상 정렬 알고리즘을 자세히 살펴보기 전에, 먼저 진입차수<sup>Indegree</sup>를 알아야한다.   
진입차수란 특정한 노드로 들어오는 간선의 개수를 의미한다. 컴공의 커리큘럼 예시에서 고급알고리즘 노드를 확인해보자. 고급 알고리즘 노드는 2개의 선수과목을 가지고 있다. 다시 말해 그래프 상에서 진입차수가 2인 것을 확인 할 수 있다. 이제 주어진 방향 그래프에서 위상 정렬을 수행하는 구체적인 알고리즘을 살펴보자. 위상 정렬 알고리즘은 다음과 같다.   
1. 진입차수가 0인 노드를 큐에 넣는다.   
2. 큐가 빌 때 까지 다음의 과정을 반복한다.   
 2-1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
 2-2. 새롭게 진입 차수가 0이 된 노드를 큐에 넣는다.   

이 알고리즘을 이용하여 간단하게 위상 정렬을 수행 할 수 있다. 알고리즘에서도 확인 할 수 있듯이 큐가 빌 때 까지 큐에서 우너소를 계속 꺼내서 처리하는 과정을 반복한다. 이때 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있다. 다시 말해 큐에서 원소가 V번 추출되기 전에 큐가 비어버리면 사이클이 발생한 것이다. 
예제 10-6.py 를 참고하자.
___   
__위상 정렬의 시간 복잡도__   
위상 정렬의 시간 복잡도는 O(V + E)이다. 위상정렬을 수행할 떄는 차례대로 모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거해야한다.   
결과적으로 노드와 간선을 모두 확인한다는 측면에서 O(V + E)의 시간이 소요된다.
