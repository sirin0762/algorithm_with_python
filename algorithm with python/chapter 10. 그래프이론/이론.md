10-1.py를 실행하면 우리가 앞서 그림으로 확인했던 것과 동일하다.   
다만 이렇게 구현하면 답을 구할 수는 있지만, find함수가 비효율적으로 동작한다.   
최악의 경우 find 함수가 모든 노드를 다 확인하는 터라 시간복잡도가 O(N) 라는 점이다.  
이 전 그림에서 노드 4를 보면 결국 루트 노드는 1이지만 3을 갔다가 2를 갔다가 1에 도착하는 것을 알수 있다.   
그러니 현재의 알고리즘을 그대로 이용하게 되면 노드의 개수가 V개이고 find 혹은 union 연산의 개수가 M개일 때, 전체 시간 복잡도는 O(VM)이 되어 비효율적이다.  

하지만 이러한 find 함수는 아주 간단한 과정으로 최적화가 가능하다. 바로 경로 압축 기법을 이용하면 시간복잡도를 개선할 수 있다.   
경로 압축은 find 함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법이다. 기존의 find 함수를 다음과 같이 변경하면 경로 압축 기법의 구현이 완료된다.
파일 10-2.py에 다음과 같은 기법을 설명했다.  

__서로소 집합 알고리즘의 시간 복잡도__   
서로소 집합 알고리즘을 구현할 때, 경로 압축 방법만을 이용할 경우의 시간 복잡도를 알아보자.   
노드의 개수가 V개 이고, 최대 V - 1개의 union 연산과 M개의 find 연산이 가능할 때 경로 압축 방법을 적용한 시간 복잡도는 O(V + M(1 + log<sub>2-M/V</sub>V))라는 것이 알려져있다.   
증명 과정은 이 책의 범위가 아니라서 생략한다. 예를 들어 노드의 개수가 1000개이고 union 및 find 연산이 100만 번 정도 수행되면, 약 1000만 번 가량의 연산이 필요하다고 이해하면 된다.

__서로소 집합을 활용한 사이클 판별__
서로소 집합은 다양한 알고리즘에 사용될 수 있다. 특히 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다는 특징이 있다. 참고로 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있으며, 해당 내용은 책에서 다루지는 않는다.   

앞서 union 연산은 그래프에서의 간선으로 표현될 수 있다고 했다. 따라서 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다.   
알고리즘은 다음과 같다.   
1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.   
1-1. 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.   
1-2. 루트 노드가 서로 같다면 사이클이 발생한 것이다.   
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.